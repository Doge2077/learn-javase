# HashMap 详解

****





如果你在 HashMap 中使用自定义的实体类作为 key，那么你确实需要合理地实现 `equals()` 和 `hashCode()` 方法。

`equals()` 方法用于比较两个对象是否相等，而 `hashCode()` 方法用于计算对象的哈希值。在 HashMap 中，当你插入一个键值对时，会使用键的哈希值来确定它在数组中的位置，并使用 `equals()` 方法来判断是否已经存在相同的键。因此，如果 `equals()` 和 `hashCode()` 方法没有正确实现，可能会导致以下问题：

1. 键无法正确匹配：如果两个键在 `equals()` 方法中被判断为相等，但它们的哈希值不同，HashMap 会认为它们是不同的键，从而可能导致无法正确地获取或删除对应的值。

2. 键冲突：如果两个键在 `equals()` 方法中被判断为不相等，但它们的哈希值相同，HashMap 会认为它们是相同的键，从而可能导致冲突，即两个键都存储在同一个槽位上，导致性能下降。

为了避免这些问题，你应该按照以下准则来实现 `equals()` 和 `hashCode()` 方法：

1. `equals()` 方法的实现应该满足以下条件：
   - 自反性：`x.equals(x)` 应该返回 `true`。
   - 对称性：如果 `x.equals(y)` 返回 `true`，那么 `y.equals(x)` 也应该返回 `true`。
   - 传递性：如果 `x.equals(y)` 返回 `true`，且 `y.equals(z)` 返回 `true`，那么 `x.equals(z)` 也应该返回 `true`。
   - 一致性：对于任意非空引用值 `x` 和 `y`，多次调用 `x.equals(y)` 应该始终返回相同的结果。
   - `x.equals(null)` 应该返回 `false`。

2. `hashCode()` 方法的实现应该满足以下条件：
   - 如果两个对象通过 `equals()` 方法比较返回 `true`，那么它们的 `hashCode()` 方法应该返回相同的值。
   - 对于不相等的对象，`hashCode()` 方法返回不同的值可以减少哈希冲突的概率，但并不是必须的。

请注意，如果你重写了 `equals()` 方法，就必须同时重写 `hashCode()` 方法，以确保它们的行为一致。否则，在使用 HashMap 时可能会出现不可预料的问题。